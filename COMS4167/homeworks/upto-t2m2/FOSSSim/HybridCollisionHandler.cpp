#include "HybridCollisionHandler.h"
#include "ContinuousTimeUtilities.h"
#include <iostream>
#include <set>
#include <algorithm>
#include "HybridCollisionComparison.h"

HybridCollisionHandler::HybridCollisionHandler(int maxiters, double COR) : ContinuousTimeCollisionHandler(COR), m_maxiters(maxiters)
{

}

HybridCollisionHandler::~HybridCollisionHandler()
{

}

void syncScene();

// Applies hybrid collision response to the simulation.
// For up to m_maxiters iterations:
//  - Find all pairs of colliding primitives using continuous-time collision detection
//  - Simultaneously apply an impulse for each detected collision
// After m_maxiters iterations, resolves remaining collisions using the failsafe, as described in the assignment instructions
//
// Does not need to be modified by students
void HybridCollisionHandler::handleCollisions(TwoDScene &scene, const VectorXs &oldpos, VectorXs &oldvel, scalar dt)
{    
    VectorXs xend(oldpos.size());
    VectorXs vend(oldvel.size());
    
    xend = scene.getX();
    vend = scene.getV();
    
    bool done = applyIterativeImpulses(scene, oldpos, scene.getX(), scene.getV(), dt, xend, vend);
    
    scene.getX() = xend;
    scene.getV() = vend;
    
    syncScene();
    
    if(!done)
        applyGeometricCollisionHandling(scene, oldpos, xend, vend, dt, scene.getX(), scene.getV());
}

// Takes start of time step and end of time step positions, and performs continuous-time collision detection.
// Inputs:
//   scene:   The simulation scene, needed for radii, etc.
//   qs:      Start of time step positions.
//   qe:      End of time step positions.
// Output:
//   Returns a list of all collisions found after performing continuous-time collision detection using positions qs and qe.
std::vector<CollisionInfo> HybridCollisionHandler::detectCollisions(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe)
{
    Vector2s n;
    double time;
    std::vector<CollisionInfo> result;
    for (int i = 0; i < scene.getNumParticles(); i++)
    {
        for (int j = i + 1; j < scene.getNumParticles(); j++)
        {
            if (detectParticleParticle(scene, qs, qe, i, j, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PP, i, j, n, time));
            }
        }
        
        for (int e = 0; e < scene.getNumEdges(); e++)
        {
            if (scene.getEdges()[e].first != i && scene.getEdges()[e].second != i)
                if (detectParticleEdge(scene, qs, qe, i, e, n, time))
                {
                    result.push_back(CollisionInfo(CollisionInfo::PE, i, e, n, time));
                }
        }

        for (int f = 0; f < scene.getNumHalfplanes(); f++)
        {
            if (detectParticleHalfplane(scene, qs, qe, i, f, n, time))
            {
                result.push_back(CollisionInfo(CollisionInfo::PH, i, f, n, time));
            }
        }
    }
    return result;
}

// Takes a list of detected collisions, positions at the start of time step, and predicted end of time step positions and velocities, and updates the
// predicted quantities by applying impulses.
// Inputs:
//   scene:      The simulation scene, needed for radii, masses, etc.
//   collisions: The list, generated by detectCollisions, of collisions that need to be responded to.
//   qs:         Start of time step positions.
//   qe:         Predicted end of time step positions.
//   qdote:      Predicted enf of time step velocities.
//   dt          The time step length
// Outputs:
//   qm:         Predicted end of time step positions after impulses have been applied. Do *NOT* pass in the same vector as for qe!
//   qdotm:      Predicted end of time step velocities after impulses have been applied.
void HybridCollisionHandler::applyImpulses(const TwoDScene &scene, const std::vector<CollisionInfo> &collisions, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    qm = qe;
    qdotm = qdote;
    for (int i = 0; i < (int)collisions.size(); i++)
    {
        switch (collisions[i].m_type)
        {
            case CollisionInfo::PP:
            {
                respondParticleParticle(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PE:
            {
                respondParticleEdge(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
            case CollisionInfo::PH:
            {
                respondParticleHalfplane(scene, qs, qe, collisions[i].m_idx1, collisions[i].m_idx2, collisions[i].m_n, collisions[i].m_time, dt, qm, qdotm);
                break;
            }
        }
    }
}



std::string HybridCollisionHandler::getName() const
{
    return "Hybrid Collision Handling";
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Impact Zone Utilities
////
////        You can use them (but please do make sure you understand what they do), or 
////        implement your own versions of whatever you need
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

bool intersects(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> temp;
    set_intersection(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(temp, temp.end()));
    return temp.size() > 0;
}

ImpactZone mergeZones(const ImpactZone &z1, const ImpactZone &z2)
{
    std::set<int> combinedverts;
    set_union(z1.m_verts.begin(), z1.m_verts.end(), z2.m_verts.begin(), z2.m_verts.end(), inserter(combinedverts, combinedverts.end()));
    return ImpactZone(combinedverts, z1.m_halfplane || z2.m_halfplane);
}


void mergeAllZones(ImpactZones &zones)
{
    ImpactZones result;
    
    ImpactZones *src = &zones;
    ImpactZones *dst = &result;
    do
    {
        dst->clear();
        for(int i=0; i<(int)src->size(); i++)
        {
            bool merged = false;
            for(int j=0; j<(int)dst->size(); j++)
            {
                if(intersects((*dst)[j], (*src)[i]))
                {
                    ImpactZone newzone = mergeZones((*dst)[j], (*src)[i]);
                    (*dst)[j] = newzone;
                    merged = true;
                    
                    break;
                }
            }
            if(!merged)
            {
                dst->push_back((*src)[i]);
            }
        }
        std::swap(src, dst);
    }
    while(src->size() < dst->size());
    
    zones = *dst;
}

void growImpactZones(const TwoDScene &scene, ImpactZones &zones, const std::vector<CollisionInfo> &impulses)
{
    for(int i=0; i<(int)impulses.size(); i++)
    {
        switch(impulses[i].m_type)
        {
            case CollisionInfo::PP:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(impulses[i].m_idx2);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PE:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                verts.insert(scene.getEdge(impulses[i].m_idx2).first);
                verts.insert(scene.getEdge(impulses[i].m_idx2).second);
                zones.push_back(ImpactZone(verts, false));
                break;
            }
            case CollisionInfo::PH:
            {
                std::set<int> verts;
                verts.insert(impulses[i].m_idx1);
                zones.push_back(ImpactZone(verts, true));
                break;
            }
        }
    }
    mergeAllZones(zones);
}

bool zonesEqual(const ImpactZones &zones1, const ImpactZones &zones2)
{
    if(zones1.size() != zones2.size())
        return false;
    
    for(int i=0; i<(int)zones1.size(); i++)
    {
        bool found = false;
        for(int j=0; j<(int)zones2.size(); j++)
        {
            if(zones1[i] == zones2[j])
            {
                found = true;
                
                break;
            }
        }
        if(!found)
            return false;
    }
    return true;
}





////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////
////
////        Student Code
////
////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////



// Iteratively performs collision detection and interative impulse response until either there are no more detected collisions, or the maximum number of
// iterations has been reached. See the assignment instructions for more details.
// The maximum number of iterations is stored in the member variable m_maxiters.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, edge endpoint indices, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qefinal:    The collision-free end-of-time-step positions (if no new collisions are detected), or the last set of predicted end-of-time-step positions
//               (if maximum number of iterations reached).
//   qdotefinal: Same as qefinal, but for velocities.
//   Returns true if the algorithm found a collision-free state. Returns false if the maximum number of iterations was reached without finding a collision-
//   free state.
// Possibly useful functions: detectCollisions, applyImpulses.
bool HybridCollisionHandler::applyIterativeImpulses(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qefinal, VectorXs &qdotefinal)
{	
    // Your implementation here
    int i;
    VectorXs i_qe;
    VectorXs i_qdote;
    std::vector<CollisionInfo> coll_detected;

    coll_detected = detectCollisions(scene, qs, qe);
    qefinal = qe;
    qdotefinal = qdote;

    for(int i = 0; i < m_maxiters && coll_detected.size() > 0; ++i)
    {
        i_qe = qefinal;
        i_qdote = qdotefinal;
        applyImpulses(scene, coll_detected, qs, qefinal, qdotefinal, dt, i_qe, i_qdote);
        qefinal = i_qe;
        qdotefinal - i_qdote;
        coll_detected = detectCollisions(scene, qs, qefinal);
    }

    if(coll_detected.size() == 0)
        return true;
    else
        return false;
}


// Resolves any remaining collisions in a simulation time step by setting the velocities of all particles involved in a way that guarantees
// that the distance between particles in an impact zone does not change.
// Inputs:
//   scene:   The simulation scene, from which the masses of the particles, current (colliding) positions, and whether or not a given particle is fixed,
//             can be retrieved.
//   qs:      The positions of the particles at the start of the time step.
//   qe:      The predicted end-of-timestep positions of the particles.
//   qdote:   The precicted end-of-timestep velocities of the particles.
//   zone:    Information about the impact zone of colliding particles. zone.m_verts is an std::set of particle indices; each particle in this set
//            is part of the impact zone and needs to have its position and velocity changed. Whether or not a half-plane is part of the impact zone
//            can be checked by looking at zone.m_halfplane.
//   dt:      The time step.
// Outputs:
//   qe:      The end-of-timestep position of the particles, assuming rigid motion as in writeup section 4.5
//   qdote:   The end-of-timestep velocity of the particles, assuming rigid motion as in writeup section 4.5
void HybridCollisionHandler::performFailsafe(const TwoDScene &scene, const VectorXs &qs, const ImpactZone &zone, double dt, VectorXs &qe, VectorXs &qdote)
{
    //
    // What you need to implement here: (same as writeup section 4.5)
    //
    Vector2s dx = qe - qs;
    VectorXs _M = scene.getM();
    Vector2s cx;
    Vector2s cm;
    Vector2s i_x, i_m;
    int i;
    double L;
    double sum_mass = 0.0;
    double w_cm = 0.0;
    double I = 0.0;
    int ct_fixed = 0;
    cx.setZero();
    cm.setZero();

    // 1. Treat the particles as if they were part of a rigid body; that is, treat them as if 
    //      we connected them with rigid beams at the start of the time step.
    for(i = 0; i < (int)zone.m_verts.size(); ++i)
    {
        cm += _M[2*i]*qs.segment<2>(2*i);
        cx += _M[2*i]*dx.segment<2>(2*i);
        sum_mass += _M[2*i];
        if(scene.isFixed(i))
            ct_fixed++;
    }
    cm = cm/sum_mass;
    cx = cx/sum_mass;
    
    // 2. Step the rigid body forward in time to the end of the time step.
    for(i = 0; i < (int)zone.m_verts.size(); ++i)
    {
        i_x = dx.segment<2>(2*i) - cx;
        i_m = qs.segment<2>(2*i) - cm;
        L += (i_m[0]*i_x[1] - i_m[1]*i_x[0]) * _M[2*i];
        I += _M[2*i] * i_m.dot(i_m);
    }
    w_cm = L/I;
    
    // Don't forget to handle fixed objects properly as in writeup section 4.5.1    
    if(ct_fixed > 0 || zone.m_halfplane)
    {
        for(i = 0; i < (int)zone.m_verts.size(); ++i)
        {
            qe.segment<2>(2*i) = qs.segment<2>(2*i);
            qdote.segment<2>(2*i).setZero();
        }
    }
    // 3. Set each particle’s modified end-of-time-step position qm to the position dictated 
    //      by the motion of the rigid body.
    // 4. Also set the particle’s modified end-of-time-step velocity to (qm − qs) / h, where 
    //      h is the length of the time step.
    //
    for(i = 0; i < (int)zone.m_verts.size(); ++i)
    {
        i_m = qs.segment<2>(2*i) - cm;
        Vector2s i_mT;
        i_mT[0] = -i_m[1];
        i_mT[1] = i_m[0];

        qe.segment<2>(2*i) = cm + cx + cos(w_cm)*i_m + sin(w_cm)*i_mT;
        qdote.segment<2>(2*i) = (qe.segment<2>(2*i) - qs.segment<2>(2*i))/dt;
    }
    return;
}


// Performs iterative geometric collision response until collision-free end-of-time-step positions and velocities are found. See the assignment
// instructions for details.
// Inputs:
//   scene:   The simulation scene. Get masses, radii, etc. from here. Do *NOT* get any positions or velocities from here.
//   qs:      The start-of-time-step positions.
//   qe:      The predicted end-of-time-step positions.
//   qdote:   The predicted end-of-time-step velocities.
//   dt:      The time step size.
// Outputs:
//   qm:    The final, collision-free end-of-time-step positions. (qm in the assignment instructions.)
//   qdotm: Same as qm, but for velocities.
// Possibly useful functions: detectCollisions, performFailsafe. You may find it helpful to write other helper functions for manipulating (merging,
// growing, etc) impact zones.
void HybridCollisionHandler::applyGeometricCollisionHandling(const TwoDScene &scene, const VectorXs &qs, const VectorXs &qe, const VectorXs &qdote, double dt, VectorXs &qm, VectorXs &qdotm)
{
    ImpactZones Z;
    ImpactZones Zprime;
    
    // Your implementation here
    
    // 1. Perform continuous-time collision detection using positions qs and qe.
    std::vector<CollisionInfo> coll_detected = detectCollisions(scene, qs, qe);
    // 2. Initialize qm = qe and qdotm = qdote.
    qm = qe;
    qdotm = qdote;
    // 3. Construct a list of disjoint impact zones Z from the detected collisions.
    growImpactZones(scene, Z, coll_detected);

    while(true)
    {
        // 4. For each impact zone in Z, apply geometric collision response (by calling 
        //      HybrdiCollisionHandler::performFailsafe, using positions qs and qm, and
        //      modifying qm and qdotm for the vertices in those zones.
        for(int i = 0; i < (int)Z.size(); ++i)
        {
            performFailsafe(scene, qs, Z[i], dt, qm, qdotm);
        }
        // 5. Perform continuous-time collision detection using positions qs and qm. 
        coll_detected = detectCollisions(scene, qs, qm);
        // 6. Construct a new list of impact zones Z′ consisting of all impact zones in Z, 
        //      plus one zone for each detected collision.
        // 7. Merge the zones in Z' to get disjoint impact zones.
        Zprime = Z;
        growImpactZones(scene, Zprime, coll_detected);
        // 8. If Z and Z' are equal, the algorithm is done, and qm and qdotm are the new, 
        //      collision-free end-of-time-step positions. Z and Z' are equal if they 
        //      contain exactly the same impact zones; impact zones are the same if they 
        //      contain the same particles and they both involve, or both don’t involve, 
        //      a half-plane. If Z != Z', go to step 9.
        if(zonesEqual(Z, Zprime))
            break;
        else
        {
            // 9. Set Z=Z' and goto step4.
            Z = Zprime;
        }
    }
    return;
}

